// help from https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/

import java.util.*; 
import java.lang.*; 
import java.io.*; 

class Prim
{ 
	// Number of vertices in the graph 
	private static final int V=5; 

	// A utility function to find the vertex with minimum key 
	// value, from the set of vertices not yet included in MST 
	int minKey(int key[], Boolean mstSet[]) 
	{ 
		// Initialize min value 
		int min = Integer.MAX_VALUE, min_index=-1; 

		for (int v = 0; v < V; v++) 
			if (mstSet[v] == false && key[v] < min) 
			{ 
				min = key[v]; 
				min_index = v; 
			} 

		return min_index; 
	} 

	// A utility function to print the constructed MST stored in 
	// parent[] 
	void printMST(int parent[], int n, int graph[][]) 
	{ 
		System.out.println("Edge \tWeight"); 
		for (int i = 1; i < V; i++) 
			System.out.println(parent[i]+" - "+ i+"\t"+ 
							graph[i][parent[i]]); 
	} 

	// Function to construct and print MST for a graph represented 
	// using adjacency matrix representation 
	void primMST(int graph[][]) 
	{ 
		// Array to store constructed MST 
		int parent[] = new int[V]; 

		// Key values used to pick minimum weight edge in cut 
		int key[] = new int [V]; 

		// To represent set of vertices not yet included in MST 
		Boolean mstSet[] = new Boolean[V]; 

		// Initialize all keys as INFINITE 
		for (int i = 0; i < V; i++) 
		{ 
			key[i] = Integer.MAX_VALUE; 
			mstSet[i] = false; 
		} 

		key[0] = 0;	 // Make key 0 so that this vertex is 
						// picked as first vertex 
		parent[0] = -1; // First node is always root of MST 

		
		for (int count = 0; count < V-1; count++) 
		{ 
			// Pick the minimum key vertex from the set of vertices 
			// not yet included in MST 
			int u = minKey(key, mstSet); 

			// Add the picked vertex to the MST Set 
			mstSet[u] = true; 

			// Update key value and parent index of the adjacent 
			// vertices of the picked vertex. Consider only those 
			// vertices which are not yet included in MST 
			for (int v = 0; v < V; v++) 

				// graph[u][v] is non zero only for adjacent vertices of m 
				// mstSet[v] is false for vertices not yet included in MST 
				// Update the key only if graph[u][v] is smaller than key[v] 
				if (graph[u][v]!=0 && mstSet[v] == false && 
					graph[u][v] < key[v]) 
				{ 
					parent[v] = u; 
					key[v] = graph[u][v]; 
				} 
		} 

		// print the constructed MST 
		printMST(parent, V, graph); 
	} 

	public static void main (String[] args) throws FileNotFoundException 
	{ 
		int graph[][] = new int[10][10];
		int start = 0, end, weight;
		File newFile = new File("graph.txt");
		Scanner in = new Scanner(newFile);
		
		
		//Read in data
		while(in.hasNextInt()) {
			start = in.nextInt();
			if(start != 999) {
				end = in.nextInt();
				weight = in.nextInt();
				graph[start][end] = weight;
			}
			
		}
		Prim t = new Prim();
		
		// Print the solution 
		t.primMST(graph); 
	} 
} 

